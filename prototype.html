<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jenner Logo Prototype Explorer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
// gif.js 0.2.0 - https://github.com/jnordberg/gif.js (inlined to avoid CDN dependency)
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GIF=f()}})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){function EventEmitter(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined}module.exports=EventEmitter;EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;EventEmitter.defaultMaxListeners=10;EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||n<0||isNaN(n))throw TypeError("n must be a positive number");this._maxListeners=n;return this};EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};if(type==="error"){if(!this._events.error||isObject(this._events.error)&&!this._events.error.length){er=arguments[1];if(er instanceof Error){throw er}else{var err=new Error('Uncaught, unspecified "error" event. ('+er+")");err.context=er;throw err}}}handler=this._events[type];if(isUndefined(handler))return false;if(isFunction(handler)){switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:args=Array.prototype.slice.call(arguments,1);handler.apply(this,args)}}else if(isObject(handler)){args=Array.prototype.slice.call(arguments,1);listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++)listeners[i].apply(this,args)}return true};EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events)this._events={};if(this._events.newListener)this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])this._events[type]=listener;else if(isObject(this._events[type]))this._events[type].push(listener);else this._events[type]=[this._events[type],listener];if(isObject(this._events[type])&&!this._events[type].warned){if(!isUndefined(this._maxListeners)){m=this._maxListeners}else{m=EventEmitter.defaultMaxListeners}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;console.error("(node) warning: possible EventEmitter memory "+"leak detected. %d listeners added. "+"Use emitter.setMaxListeners() to increase limit.",this._events[type].length);if(typeof console.trace==="function"){console.trace()}}}return this};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError("listener must be a function");var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments)}}g.listener=listener;this.on(type,g);return this};EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit("removeListener",type,listener)}else if(isObject(list)){for(i=length;i-- >0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type]}else{list.splice(position,1)}if(this._events.removeListener)this.emit("removeListener",type,listener)}return this};EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this}if(arguments.length===0){for(key in this._events){if(key==="removeListener")continue;this.removeAllListeners(key)}this.removeAllListeners("removeListener");this._events={};return this}listeners=this._events[type];if(isFunction(listeners)){this.removeListener(type,listeners)}else if(listeners){while(listeners.length)this.removeListener(type,listeners[listeners.length-1])}delete this._events[type];return this};EventEmitter.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret};EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;else if(evlistener)return evlistener.length}return 0};EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type)};function isFunction(arg){return typeof arg==="function"}function isNumber(arg){return typeof arg==="number"}function isObject(arg){return typeof arg==="object"&&arg!==null}function isUndefined(arg){return arg===void 0}},{}],2:[function(require,module,exports){var UA,browser,mode,platform,ua;ua=navigator.userAgent.toLowerCase();platform=navigator.platform.toLowerCase();UA=ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/)||[null,"unknown",0];mode=UA[1]==="ie"&&document.documentMode;browser={name:UA[1]==="version"?UA[3]:UA[1],version:mode||parseFloat(UA[1]==="opera"&&UA[4]?UA[4]:UA[2]),platform:{name:ua.match(/ip(?:ad|od|hone)/)?"ios":(ua.match(/(?:webos|android)/)||platform.match(/mac|win|linux/)||["other"])[0]}};browser[browser.name]=true;browser[browser.name+parseInt(browser.version,10)]=true;browser.platform[browser.platform.name]=true;module.exports=browser},{}],3:[function(require,module,exports){var EventEmitter,GIF,browser,extend=function(child,parent){for(var key in parent){if(hasProp.call(parent,key))child[key]=parent[key]}function ctor(){this.constructor=child}ctor.prototype=parent.prototype;child.prototype=new ctor;child.__super__=parent.prototype;return child},hasProp={}.hasOwnProperty,indexOf=[].indexOf||function(item){for(var i=0,l=this.length;i<l;i++){if(i in this&&this[i]===item)return i}return-1},slice=[].slice;EventEmitter=require("events").EventEmitter;browser=require("./browser.coffee");GIF=function(superClass){var defaults,frameDefaults;extend(GIF,superClass);defaults={workerScript:"gif.worker.js",workers:2,repeat:0,background:"#fff",quality:10,width:null,height:null,transparent:null,debug:false,dither:false};frameDefaults={delay:500,copy:false};function GIF(options){var base,key,value;this.running=false;this.options={};this.frames=[];this.freeWorkers=[];this.activeWorkers=[];this.setOptions(options);for(key in defaults){value=defaults[key];if((base=this.options)[key]==null){base[key]=value}}}GIF.prototype.setOption=function(key,value){this.options[key]=value;if(this._canvas!=null&&(key==="width"||key==="height")){return this._canvas[key]=value}};GIF.prototype.setOptions=function(options){var key,results,value;results=[];for(key in options){if(!hasProp.call(options,key))continue;value=options[key];results.push(this.setOption(key,value))}return results};GIF.prototype.addFrame=function(image,options){var frame,key;if(options==null){options={}}frame={};frame.transparent=this.options.transparent;for(key in frameDefaults){frame[key]=options[key]||frameDefaults[key]}if(this.options.width==null){this.setOption("width",image.width)}if(this.options.height==null){this.setOption("height",image.height)}if(typeof ImageData!=="undefined"&&ImageData!==null&&image instanceof ImageData){frame.data=image.data}else if(typeof CanvasRenderingContext2D!=="undefined"&&CanvasRenderingContext2D!==null&&image instanceof CanvasRenderingContext2D||typeof WebGLRenderingContext!=="undefined"&&WebGLRenderingContext!==null&&image instanceof WebGLRenderingContext){if(options.copy){frame.data=this.getContextData(image)}else{frame.context=image}}else if(image.childNodes!=null){if(options.copy){frame.data=this.getImageData(image)}else{frame.image=image}}else{throw new Error("Invalid image")}return this.frames.push(frame)};GIF.prototype.render=function(){var i,j,numWorkers,ref;if(this.running){throw new Error("Already running")}if(this.options.width==null||this.options.height==null){throw new Error("Width and height must be set prior to rendering")}this.running=true;this.nextFrame=0;this.finishedFrames=0;this.imageParts=function(){var j,ref,results;results=[];for(i=j=0,ref=this.frames.length;0<=ref?j<ref:j>ref;i=0<=ref?++j:--j){results.push(null)}return results}.call(this);numWorkers=this.spawnWorkers();if(this.options.globalPalette===true){this.renderNextFrame()}else{for(i=j=0,ref=numWorkers;0<=ref?j<ref:j>ref;i=0<=ref?++j:--j){this.renderNextFrame()}}this.emit("start");return this.emit("progress",0)};GIF.prototype.abort=function(){var worker;while(true){worker=this.activeWorkers.shift();if(worker==null){break}this.log("killing active worker");worker.terminate()}this.running=false;return this.emit("abort")};GIF.prototype.spawnWorkers=function(){var j,numWorkers,ref,results;numWorkers=Math.min(this.options.workers,this.frames.length);(function(){results=[];for(var j=ref=this.freeWorkers.length;ref<=numWorkers?j<numWorkers:j>numWorkers;ref<=numWorkers?j++:j--){results.push(j)}return results}).apply(this).forEach(function(_this){return function(i){var worker;_this.log("spawning worker "+i);worker=new Worker(_this.options.workerScript);worker.onmessage=function(event){_this.activeWorkers.splice(_this.activeWorkers.indexOf(worker),1);_this.freeWorkers.push(worker);return _this.frameFinished(event.data)};return _this.freeWorkers.push(worker)}}(this));return numWorkers};GIF.prototype.frameFinished=function(frame){var i,j,ref;this.log("frame "+frame.index+" finished - "+this.activeWorkers.length+" active");this.finishedFrames++;this.emit("progress",this.finishedFrames/this.frames.length);this.imageParts[frame.index]=frame;if(this.options.globalPalette===true){this.options.globalPalette=frame.globalPalette;this.log("global palette analyzed");if(this.frames.length>2){for(i=j=1,ref=this.freeWorkers.length;1<=ref?j<ref:j>ref;i=1<=ref?++j:--j){this.renderNextFrame()}}}if(indexOf.call(this.imageParts,null)>=0){return this.renderNextFrame()}else{return this.finishRendering()}};GIF.prototype.finishRendering=function(){var data,frame,i,image,j,k,l,len,len1,len2,len3,offset,page,ref,ref1,ref2;len=0;ref=this.imageParts;for(j=0,len1=ref.length;j<len1;j++){frame=ref[j];len+=(frame.data.length-1)*frame.pageSize+frame.cursor}len+=frame.pageSize-frame.cursor;this.log("rendering finished - filesize "+Math.round(len/1e3)+"kb");data=new Uint8Array(len);offset=0;ref1=this.imageParts;for(k=0,len2=ref1.length;k<len2;k++){frame=ref1[k];ref2=frame.data;for(i=l=0,len3=ref2.length;l<len3;i=++l){page=ref2[i];data.set(page,offset);if(i===frame.data.length-1){offset+=frame.cursor}else{offset+=frame.pageSize}}}image=new Blob([data],{type:"image/gif"});return this.emit("finished",image,data)};GIF.prototype.renderNextFrame=function(){var frame,task,worker;if(this.freeWorkers.length===0){throw new Error("No free workers")}if(this.nextFrame>=this.frames.length){return}frame=this.frames[this.nextFrame++];worker=this.freeWorkers.shift();task=this.getTask(frame);this.log("starting frame "+(task.index+1)+" of "+this.frames.length);this.activeWorkers.push(worker);return worker.postMessage(task)};GIF.prototype.getContextData=function(ctx){return ctx.getImageData(0,0,this.options.width,this.options.height).data};GIF.prototype.getImageData=function(image){var ctx;if(this._canvas==null){this._canvas=document.createElement("canvas");this._canvas.width=this.options.width;this._canvas.height=this.options.height}ctx=this._canvas.getContext("2d");ctx.setFill=this.options.background;ctx.fillRect(0,0,this.options.width,this.options.height);ctx.drawImage(image,0,0);return this.getContextData(ctx)};GIF.prototype.getTask=function(frame){var index,task;index=this.frames.indexOf(frame);task={index:index,last:index===this.frames.length-1,delay:frame.delay,transparent:frame.transparent,width:this.options.width,height:this.options.height,quality:this.options.quality,dither:this.options.dither,globalPalette:this.options.globalPalette,repeat:this.options.repeat,canTransfer:browser.name==="chrome"};if(frame.data!=null){task.data=frame.data}else if(frame.context!=null){task.data=this.getContextData(frame.context)}else if(frame.image!=null){task.data=this.getImageData(frame.image)}else{throw new Error("Invalid frame")}return task};GIF.prototype.log=function(){var args;args=1<=arguments.length?slice.call(arguments,0):[];if(!this.options.debug){return}return console.log.apply(console,args)};return GIF}(EventEmitter);module.exports=GIF},{"./browser.coffee":2,events:1}]},{},[3])(3)});
</script>
<script>
// gif.worker.js 0.2.0 - inlined as blob URL for offline use
window._gifWorkerBlobURL = (function() {
  var workerCode = '// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js\n' +
    '(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module \'"+o+"\'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);';
  var blob = new Blob([workerCode], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
})();
</script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', system-ui, sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    padding: 24px;
    min-height: 100vh;
  }
  h1 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 4px;
    letter-spacing: -0.3px;
  }
  .subtitle {
    font-size: 13px;
    color: #888;
    margin-bottom: 24px;
  }
  .controls {
    background: #222;
    border-radius: 12px;
    padding: 16px 20px;
    margin-bottom: 24px;
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    align-items: flex-start;
  }
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .control-group label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #777;
    font-weight: 600;
  }
  .toggle-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }
  .toggle-btn {
    padding: 5px 12px;
    border-radius: 6px;
    border: 1px solid #444;
    background: transparent;
    color: #bbb;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  .toggle-btn.active {
    background: #3a3a3a;
    color: #fff;
    border-color: #666;
  }
  .toggle-btn:hover { border-color: #888; }
  .speed-control {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .speed-control input[type="range"] {
    width: 100px;
    accent-color: #888;
  }
  .speed-val {
    font-size: 12px;
    color: #aaa;
    min-width: 32px;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 16px;
  }
  .grid.favicon-mode {
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  }
  .card {
    background: #222;
    border-radius: 12px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    transition: outline 0.15s, transform 0.15s;
    outline: 2px solid transparent;
  }
  .card:hover {
    outline-color: #444;
    transform: translateY(-1px);
  }
  .card.paused { outline-color: #665522; }
  .card canvas {
    border-radius: 8px;
    image-rendering: auto;
  }
  .card-id {
    font-size: 13px;
    font-weight: 700;
    color: #555;
    font-family: 'SF Mono', 'Menlo', monospace;
    letter-spacing: 0.5px;
  }
  .card-label {
    font-size: 10px;
    color: #777;
    text-align: center;
    line-height: 1.5;
    letter-spacing: 0.3px;
  }
  .card-label span {
    display: inline-block;
    background: #2a2a2a;
    padding: 1px 6px;
    border-radius: 3px;
    margin: 1px;
  }

  /* ---- Editor / Detail view ---- */
  #detail {
    display: none;
  }
  #detail.active {
    display: block;
  }
  .editor-header {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 20px;
  }
  .editor-header h2 {
    font-size: 18px;
    font-weight: 600;
  }
  .editor-back-btn, .editor-copy-btn {
    padding: 6px 14px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #2a2a2a;
    color: #ccc;
    font-size: 13px;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.15s;
  }
  .editor-back-btn:hover, .editor-copy-btn:hover {
    border-color: #888;
    color: #fff;
  }
  .editor-copy-btn {
    background: #3a5a3a;
    border-color: #5a8a5a;
  }
  .editor-copy-btn:hover {
    background: #4a6a4a;
  }
  .editor-layout {
    display: flex;
    gap: 32px;
    flex-wrap: wrap;
  }
  .editor-preview {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }
  #editor-canvas {
    border-radius: 12px;
  }
  .editor-playback {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .editor-playback button {
    padding: 4px 12px;
    border-radius: 5px;
    border: 1px solid #444;
    background: #2a2a2a;
    color: #ccc;
    font-size: 12px;
    cursor: pointer;
    font-family: inherit;
  }
  .editor-playback button:hover { border-color: #888; }
  .editor-playback button.active { background: #3a3a3a; border-color: #666; color: #fff; }
  .editor-controls {
    flex: 1;
    min-width: 300px;
    display: flex;
    flex-direction: column;
    gap: 18px;
  }
  .editor-section {
    background: #222;
    border-radius: 10px;
    padding: 14px 16px;
  }
  .editor-section h3 {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #777;
    font-weight: 600;
    margin-bottom: 10px;
  }
  .weight-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
  }
  .weight-grid input {
    width: 100%;
    padding: 5px;
    border-radius: 5px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #ddd;
    font-size: 13px;
    font-family: 'SF Mono', Menlo, monospace;
    text-align: center;
  }
  .weight-grid input:focus {
    outline: none;
    border-color: #888;
  }
  .editor-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
  }
  .editor-row label {
    font-size: 12px;
    color: #aaa;
    min-width: 90px;
  }
  .editor-row input[type="range"] {
    flex: 1;
    accent-color: #888;
  }
  .editor-row .val {
    font-size: 12px;
    color: #aaa;
    min-width: 40px;
    text-align: right;
    font-family: 'SF Mono', Menlo, monospace;
  }
  .editor-row input[type="color"] {
    width: 36px;
    height: 28px;
    border: 1px solid #444;
    border-radius: 4px;
    background: none;
    cursor: pointer;
    padding: 0;
  }
  .editor-row input[type="text"].hex-input {
    width: 80px;
    padding: 4px 8px;
    border-radius: 5px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #ddd;
    font-size: 12px;
    font-family: 'SF Mono', Menlo, monospace;
  }
  .color-presets {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-bottom: 10px;
  }
  .color-preset-btn {
    padding: 4px 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background: transparent;
    color: #bbb;
    font-size: 11px;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.15s;
  }
  .color-preset-btn.active {
    background: #3a3a3a;
    border-color: #666;
    color: #fff;
  }
  .color-preset-btn:hover { border-color: #888; }
  .grid-divider {
    grid-column: 1 / -1;
    border-top: 1px solid #333;
    padding-top: 12px;
    margin-top: 4px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #666;
    font-weight: 600;
  }
  .card.custom-card {
    outline-color: #443300;
  }
  .card.custom-card:hover {
    outline-color: #665500;
  }
  .config-output {
    width: 100%;
    min-height: 200px;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #ccc;
    font-size: 11px;
    font-family: 'SF Mono', Menlo, monospace;
    resize: vertical;
    margin-top: 8px;
  }
  .export-btn {
    width: 100%;
    padding: 10px 16px;
    border-radius: 8px;
    border: 1px solid #5a8a5a;
    background: #3a5a3a;
    color: #ddd;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.15s;
    margin-top: 8px;
  }
  .export-btn:hover { background: #4a6a4a; color: #fff; }
  .export-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  #export-progress {
    margin-top: 10px;
  }
  #export-progress progress {
    width: 100%;
    height: 8px;
    border-radius: 4px;
    appearance: none;
    -webkit-appearance: none;
    overflow: hidden;
  }
  #export-progress progress::-webkit-progress-bar {
    background: #1a1a1a;
    border-radius: 4px;
  }
  #export-progress progress::-webkit-progress-value {
    background: #5a8a5a;
    border-radius: 4px;
  }
  #export-status {
    display: block;
    font-size: 11px;
    color: #888;
    margin-top: 4px;
  }
  .period-selector {
    display: flex;
    gap: 4px;
    margin-bottom: 10px;
    flex-wrap: wrap;
  }
  .period-btn {
    padding: 4px 10px;
    border-radius: 5px;
    border: 1px solid #444;
    background: transparent;
    color: #888;
    font-size: 11px;
    cursor: pointer;
    font-family: 'SF Mono', Menlo, monospace;
    transition: all 0.15s;
    min-width: 28px;
    text-align: center;
  }
  .period-btn.active {
    background: #3a3a3a;
    border-color: #666;
    color: #fff;
  }
  .period-btn.current-frame {
    border-color: #5a8a5a;
    box-shadow: 0 0 4px rgba(90, 138, 90, 0.4);
  }
  .period-btn:hover { border-color: #888; }
  .export-frame-select {
    width: 100%;
    padding: 5px 8px;
    border-radius: 5px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #ddd;
    font-size: 12px;
    font-family: inherit;
  }
</style>
</head>
<body>

<h1>Jenner Logo Prototype Explorer</h1>
<p class="subtitle">Click to pause/resume. Double-click to open editor. Use filters to narrow down variations.</p>

<div class="controls">
  <div class="control-group">
    <label>J Variant</label>
    <div class="toggle-row" id="filter-variant"></div>
  </div>
  <div class="control-group">
    <label>Dot Shape</label>
    <div class="toggle-row" id="filter-shape"></div>
  </div>
  <div class="control-group">
    <label>Color Scheme</label>
    <div class="toggle-row" id="filter-color"></div>
  </div>
  <div class="control-group">
    <label>Sizing</label>
    <div class="toggle-row" id="filter-sizing"></div>
  </div>
  <div class="control-group">
    <label>Speed</label>
    <div class="speed-control">
      <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
      <span class="speed-val" id="speed-val">1×</span>
    </div>
  </div>
  <div class="control-group">
    <label>Rotation</label>
    <div class="toggle-row">
      <button class="toggle-btn active" id="smooth-toggle">Smooth</button>
    </div>
  </div>
  <div class="control-group">
    <label>Preview</label>
    <div class="toggle-row">
      <button class="toggle-btn" id="favicon-toggle">Favicon size</button>
    </div>
  </div>
  <div class="control-group" style="flex-basis:100%;">
    <label>Current filters (click to copy)</label>
    <div id="filter-summary" style="font-family:'SF Mono',Menlo,monospace; font-size:11px; color:#aaa; background:#2a2a2a; padding:6px 10px; border-radius:6px; cursor:pointer; user-select:all; white-space:nowrap; overflow-x:auto;"></div>
  </div>
</div>

<div class="grid" id="grid"></div>

<div id="detail">
  <div class="editor-header">
    <button class="editor-back-btn" id="editor-back">← Back to grid</button>
    <h2 id="editor-title">Editing #01</h2>
    <button class="editor-copy-btn" id="editor-copy">Copy config</button>
  </div>
  <div class="editor-layout">
    <div class="editor-preview">
      <canvas id="editor-canvas" width="300" height="300"></canvas>
      <div class="editor-playback">
        <button id="ep-play" class="active">▶ Play</button>
        <button id="ep-pause">⏸ Pause</button>
        <button id="ep-step">⏭ Step</button>
        <div class="speed-control" style="margin-left:8px;">
          <input type="range" id="editor-speed" min="0.1" max="3" step="0.1" value="1">
          <span class="speed-val" id="editor-speed-val">1×</span>
        </div>
      </div>
    </div>
    <div class="editor-controls">
      <div class="editor-section">
        <h3>Playback Mode</h3>
        <div class="editor-row">
          <label>Skip build-up</label>
          <button class="toggle-btn" id="editor-skip-build">Off</button>
        </div>
      </div>
      <div class="editor-section">
        <h3>Weight Matrix (3×3 dot sizes)</h3>
        <div class="editor-row" style="margin-bottom:6px;">
          <label>Period</label>
        </div>
        <div class="period-selector" id="editor-period-selector"></div>
        <div class="weight-grid" id="editor-weights"></div>
      </div>
      <div class="editor-section">
        <h3>Dot Shape</h3>
        <div class="toggle-row" id="editor-shape-row">
          <button class="toggle-btn" data-shape="circle">Circle</button>
          <button class="toggle-btn" data-shape="squircle">Squircle</button>
        </div>
      </div>
      <div class="editor-section">
        <h3>Color Scheme</h3>
        <div class="color-presets" id="editor-color-presets"></div>
        <div class="editor-row">
          <label>Background</label>
          <input type="color" id="editor-bg-picker">
          <input type="text" class="hex-input" id="editor-bg-hex">
        </div>
        <div class="editor-row">
          <label>Dot color</label>
          <input type="color" id="editor-dot-picker">
          <input type="text" class="hex-input" id="editor-dot-hex">
        </div>
      </div>
      <div class="editor-section">
        <h3>Base Dot Size Ratio</h3>
        <div class="editor-row">
          <label>Size</label>
          <input type="range" id="editor-dot-ratio" min="0.2" max="0.95" step="0.05" value="0.6">
          <span class="val" id="editor-dot-ratio-val">0.60</span>
        </div>
      </div>
      <div class="editor-section">
        <h3>Animation Timing</h3>
        <div id="editor-timings"></div>
      </div>
      <div class="editor-section">
        <h3>Exported Config</h3>
        <textarea class="config-output" id="editor-config-output" readonly></textarea>
      </div>
      <div class="editor-section">
        <h3>Export Asset Pack</h3>
        <div class="editor-row">
          <label>Frame</label>
          <select id="export-frame" class="export-frame-select">
            <option value="canonical" selected>Canonical (J visible)</option>
            <option value="current">Current frame</option>
          </select>
        </div>
        <button class="export-btn" id="export-btn">Download Asset Pack (.zip)</button>
        <div id="export-progress" style="display:none">
          <progress id="export-bar" max="100" value="0"></progress>
          <span id="export-status">Generating...</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============ DATA ============

// J variants
const VARIANT_DEFS = {
  // User's new pattern — open-center J, 6 dots, rotates smoothly
  'hook-6': {
    canonical: [[0,0,1],[1,0,1],[1,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,1]],
      [[0,0,1],[0,0,1],[1,1,1]],
      [[0,0,1],[1,0,1],[1,1,1]],
    ]
  },
  // Staircase J — 6 dots, diagonal flow
  'stair-6': {
    canonical: [[0,0,1],[0,1,1],[1,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,0]],
      [[0,0,1],[0,1,1],[0,0,0]],
      [[0,0,1],[0,1,1],[0,0,1]],
      [[0,0,1],[0,1,1],[1,1,1]],
    ]
  },
  // L-shape — 5 dots, clean right-angle
  'L-5': {
    canonical: [[0,0,1],[0,0,1],[1,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,1]],
      [[0,0,1],[0,0,1],[0,1,1]],
      [[0,0,1],[0,0,1],[1,1,1]],
    ]
  },
  // Original right-column J from spec — 5 dots
  'right-5': {
    canonical: [[0,0,1],[0,1,1],[0,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,1]],
      [[0,0,1],[0,0,1],[0,1,1]],
      [[0,0,1],[0,1,1],[0,1,1]],
    ]
  },
  // Heavy J — 7 dots, filled bottom
  'heavy-7': {
    canonical: [[0,0,1],[1,1,1],[1,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,0]],
      [[0,0,1],[0,0,1],[0,0,1]],
      [[0,0,1],[0,1,1],[0,1,1]],
      [[0,0,1],[1,1,1],[1,1,1]],
    ]
  },
  // Loop-8 — all 8 edge dots, center empty
  // The J reads via dot SIZE (trail sizing), not presence/absence
  'loop-8': {
    canonical: [[1,1,1],[1,0,1],[1,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],          // stem top
      [[0,0,1],[0,0,1],[0,0,0]],          // stem grows
      [[0,0,1],[0,0,1],[1,1,1]],          // stem + base
      [[0,0,1],[1,0,1],[1,1,1]],          // full J (hook-6)
      [[1,1,1],[1,0,1],[1,1,1]],          // trail dots complete the loop
    ]
  },
  // Full-9 — all 9 cells filled, J reads entirely through dot size
  'full-9': {
    canonical: [[1,1,1],[1,1,1],[1,1,1]],
    buildUp: [
      [[0,0,1],[0,0,0],[0,0,0]],          // stem top
      [[0,0,1],[0,0,1],[0,0,0]],          // stem grows
      [[0,0,1],[0,0,1],[1,1,1]],          // stem + base
      [[0,0,1],[1,0,1],[1,1,1]],          // J shape visible
      [[1,1,1],[1,1,1],[1,1,1]],          // all dots fill in
    ]
  },
};

function buildUpFrames(variant) {
  return VARIANT_DEFS[variant].buildUp;
}

// 90° clockwise rotation of 3x3 matrix
function rotate90(m) {
  const r = [[0,0,0],[0,0,0],[0,0,0]];
  for (let i = 0; i < 3; i++)
    for (let j = 0; j < 3; j++)
      r[i][j] = m[2-j][i];
  return r;
}

// Build rotation frame matrices for N periods (cycling through 4 orientations)
function buildRotationMatrices(variant, n) {
  const canonical = VARIANT_DEFS[variant].canonical;
  const r1 = rotate90(canonical);
  const r2 = rotate90(r1);
  const r3 = rotate90(r2);
  const cycle = [canonical, r1, r2, r3];
  const result = [];
  for (let i = 0; i < n; i++) result.push(cycle[i % 4]);
  return result;
}

// Build full frame sequence: build-up + rotation loop
// opts: { skipBuild: bool, rotationPeriods: number, customRotWeights: array }
function buildFrameSequence(variant, sizingMode, opts) {
  opts = opts || {};
  const skipBuild = opts.skipBuild || false;
  const rotPeriods = opts.rotationPeriods || 4;

  const rotMatrices = buildRotationMatrices(variant, rotPeriods);

  // Build rotation weight frames
  const baseW = SIZING_WEIGHTS[sizingMode];
  let rotWeights;
  if (opts.customRotWeights) {
    rotWeights = opts.customRotWeights;
  } else if (sizingMode === 'wave' || sizingMode === 'trail') {
    const wr1 = rotateWeights(baseW);
    const wr2 = rotateWeights(wr1);
    const wr3 = rotateWeights(wr2);
    const wCycle = [baseW, wr1, wr2, wr3];
    rotWeights = [];
    for (let i = 0; i < rotPeriods; i++) rotWeights.push(wCycle[i % 4]);
  } else {
    rotWeights = Array(rotPeriods).fill(baseW);
  }

  if (skipBuild) {
    return {
      frames: rotMatrices,
      weights: rotWeights,
      timings: Array(rotPeriods).fill(140),
      loopStart: 1,
    };
  }

  const buildFrames = buildUpFrames(variant);
  const buildTimings = [120, 120, 120, 140, 180];
  const buildWeights = Array(buildFrames.length).fill(rotWeights[0]);

  return {
    frames: [...buildFrames, ...rotMatrices.slice(1)],
    weights: [...buildWeights, ...rotWeights.slice(1)],
    timings: [...buildTimings, ...Array(rotPeriods - 1).fill(140)],
    loopStart: buildFrames.length,
  };
}

// Color schemes
const COLOR_SCHEMES = {
  'dark/light': { bg: '#1c1c1e', dot: '#f0efe8' },
  'light/dark': { bg: '#f0efe8', dot: '#1c1c1e' },
  'dark/amber': { bg: '#1c1c1e', dot: '#e8a435' },
};

// Base dot size ratio (dot diameter / cell size)
const BASE_DOT_RATIO = 0.6;

// Sizing modes: weight matrices that control per-dot scale
// "wave" rotates with the pattern; "corner" is rotation-invariant
const SIZING_WEIGHTS = {
  // All dots same size
  'uniform': [
    [1.0, 1.0, 1.0],
    [1.0, 1.0, 1.0],
    [1.0, 1.0, 1.0],
  ],
  // Directional emphasis — top row large, bottom small
  // Rotates with the pattern, creating a "leading edge" wave effect
  'wave': [
    [1.3, 1.3, 1.3],
    [1.0, 1.0, 1.0],
    [0.7, 0.7, 0.7],
  ],
  // Corners pop, edges recede — structural hierarchy (rotation-invariant)
  'corner': [
    [1.25, 0.85, 1.25],
    [0.85, 1.1,  0.85],
    [1.25, 0.85, 1.25],
  ],
  // Trail — J stem is large, trailing dots shrink around the perimeter
  // Perimeter CW from (0,2): stem top → hook end → trail dots
  // Rotates with the pattern so the gradient follows the spin
  // Center is small (background texture, not part of J)
  'trail': [
    [0.40, 0.30, 1.30],
    [0.55, 0.30, 1.15],
    [0.70, 0.85, 1.00],
  ],
};

// Rotate a weight matrix 90° CW (same transform as dot matrix)
function rotateWeights(w) {
  const r = [[0,0,0],[0,0,0],[0,0,0]];
  for (let i = 0; i < 3; i++)
    for (let j = 0; j < 3; j++)
      r[i][j] = w[2-j][i];
  return r;
}

// ============ RENDERING ============

function drawFrame(ctx, matrix, size, dotShape, colorScheme, weights, opts) {
  const colors = (opts && opts.colors) || COLOR_SCHEMES[colorScheme];
  const { bg, dot } = colors;
  const dotRatio = (opts && opts.baseDotRatio) || BASE_DOT_RATIO;
  const cellSize = size / 3;
  const baseDotR = (cellSize * dotRatio) / 2;
  const squircleRadius = baseDotR * 0.35;

  // Background
  ctx.clearRect(0, 0, size, size);
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, size, size);

  // Dots
  ctx.fillStyle = dot;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (!matrix[r][c]) continue;
      const scale = weights[r][c];
      const dotR = baseDotR * scale;
      const cx = cellSize * c + cellSize / 2;
      const cy = cellSize * r + cellSize / 2;
      if (dotShape === 'circle') {
        ctx.beginPath();
        ctx.arc(cx, cy, dotR, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // squircle (rounded rect)
        const sr = dotR * 0.35;
        const s = dotR * 2;
        ctx.beginPath();
        ctx.roundRect(cx - dotR, cy - dotR, s, s, sr);
        ctx.fill();
      }
    }
  }
}

// Interpolated draw: cross-fades between two frames for smooth rotation
function drawFrameInterp(ctx, matA, matB, size, dotShape, colorScheme, weightsA, weightsB, t, opts) {
  const colors = (opts && opts.colors) || COLOR_SCHEMES[colorScheme];
  const { bg, dot } = colors;
  const dotRatio = (opts && opts.baseDotRatio) || BASE_DOT_RATIO;
  const cellSize = size / 3;
  const baseDotR = (cellSize * dotRatio) / 2;

  // Smoothstep easing for more natural motion
  const st = t * t * (3 - 2 * t);

  ctx.clearRect(0, 0, size, size);
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, size, size);

  ctx.fillStyle = dot;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const inA = matA[r][c];
      const inB = matB[r][c];
      if (!inA && !inB) continue;

      let scale;
      if (inA && inB) {
        scale = weightsA[r][c] * (1 - st) + weightsB[r][c] * st;
      } else if (inA) {
        scale = weightsA[r][c] * (1 - st);
      } else {
        scale = weightsB[r][c] * st;
      }
      if (scale < 0.01) continue;

      const dotR = baseDotR * scale;
      const cx = cellSize * c + cellSize / 2;
      const cy = cellSize * r + cellSize / 2;
      if (dotShape === 'circle') {
        ctx.beginPath();
        ctx.arc(cx, cy, dotR, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const sr = dotR * 0.35;
        const s = dotR * 2;
        ctx.beginPath();
        ctx.roundRect(cx - dotR, cy - dotR, s, s, sr);
        ctx.fill();
      }
    }
  }
}

// ============ ANIMATION ENGINE ============

const allCards = [];
let globalSpeed = 1;
let smoothRotation = true;
let faviconMode = false;
let cardCounter = 0;

class LogoCard {
  constructor(config) {
    // Use explicit stableId if provided, otherwise auto-increment
    this.id = config.stableId || String(++cardCounter).padStart(2, '0');
    this.variant = config.variant;
    this.shape = config.shape;
    this.color = config.color;
    this.sizing = config.sizing;
    this.customName = config.customName || null;
    this.customColors = config.customColors || null;   // {bg, dot}
    this.customBaseSize = config.customBaseSize || null;
    this.customWeights = config.customWeights || null;  // 3x3 matrix (legacy)
    this.skipBuild = config.skipBuild || false;
    this.rotationPeriods = config.rotationPeriods || 4;
    this.paused = false;
    this.visible = true;

    const seqOpts = {
      skipBuild: this.skipBuild,
      rotationPeriods: this.rotationPeriods,
    };

    // Convert legacy customWeights to customRotWeights for buildFrameSequence
    if (config.customRotWeights) {
      seqOpts.customRotWeights = config.customRotWeights;
    } else if (this.customWeights) {
      const w0 = this.customWeights;
      const w1 = rotateWeights(w0);
      const w2 = rotateWeights(w1);
      const w3 = rotateWeights(w2);
      const wCycle = [w0, w1, w2, w3];
      seqOpts.customRotWeights = [];
      for (let i = 0; i < this.rotationPeriods; i++) {
        seqOpts.customRotWeights.push(wCycle[i % 4]);
      }
    }

    const seq = buildFrameSequence(this.variant, this.sizing, seqOpts);
    this.frames = seq.frames;
    this.timings = seq.timings;
    this.loopStart = seq.loopStart;
    this.weights = seq.weights;

    // centerProfile: per-frame override for weights[1][1] (center dot)
    // Allows center to fluctuate — small when J is visible, larger during rotation
    if (config.centerProfile) {
      this.weights = this.weights.map((w, i) => {
        if (config.centerProfile[i] === undefined) return w;
        const copy = w.map(r => [...r]);
        copy[1][1] = config.centerProfile[i];
        return copy;
      });
    }

    // Animation state
    this.currentFrame = 0;
    this.elapsed = 0;
    this.inLoop = false;

    // DOM
    this.el = document.createElement('div');
    this.el.className = 'card';

    const idLabel = document.createElement('div');
    idLabel.className = 'card-id';
    idLabel.textContent = '#' + this.id;
    this.el.appendChild(idLabel);

    this.canvas = document.createElement('canvas');
    this.el.appendChild(this.canvas);

    const label = document.createElement('div');
    label.className = 'card-label';
    if (this.customName) {
      label.innerHTML = `<span>${this.customName}</span> <span>${this.variant}</span> <span>${this.shape}</span>`;
    } else {
      label.innerHTML = `<span>${this.variant}</span> <span>${this.shape}</span> <span>${this.color}</span> <span>${this.sizing}</span>`;
    }
    this.el.appendChild(label);

    this.el.addEventListener('click', () => {
      this.paused = !this.paused;
      this.el.classList.toggle('paused', this.paused);
    });
    this.el.addEventListener('dblclick', (e) => {
      e.preventDefault();
      showEditor(this);
    });

    this.resize();
  }

  resize() {
    const s = faviconMode ? 32 : 160;
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = s * dpr;
    this.canvas.height = s * dpr;
    this.canvas.style.width = s + 'px';
    this.canvas.style.height = s + 'px';
    this.ctx = this.canvas.getContext('2d');
    this.ctx.scale(dpr, dpr);
    this.renderSize = s;
  }

  update(dt) {
    if (this.paused || !this.visible) return;
    this.elapsed += dt * globalSpeed;

    const frameDuration = this.timings[this.currentFrame];
    if (this.elapsed >= frameDuration) {
      this.elapsed -= frameDuration;
      this.currentFrame++;

      // Handle looping
      if (this.currentFrame >= this.frames.length) {
        this.currentFrame = this.loopStart - 1;
        this.inLoop = true;
      }
    }
    // Interpolation factor (0-1) within current frame
    this.interpT = Math.min(this.elapsed / this.timings[this.currentFrame], 1);
  }

  draw() {
    if (!this.visible) return;
    const opts = {};
    if (this.customColors) opts.colors = this.customColors;
    if (this.customBaseSize) opts.baseDotRatio = this.customBaseSize;
    const hasOpts = Object.keys(opts).length ? opts : undefined;

    const inRotation = this.currentFrame >= this.loopStart - 1;
    if (smoothRotation && inRotation) {
      let next = this.currentFrame + 1;
      if (next >= this.frames.length) next = this.loopStart - 1;
      drawFrameInterp(
        this.ctx,
        this.frames[this.currentFrame], this.frames[next],
        this.renderSize, this.shape, this.color,
        this.weights[this.currentFrame], this.weights[next],
        this.interpT || 0,
        hasOpts
      );
    } else {
      drawFrame(
        this.ctx,
        this.frames[this.currentFrame],
        this.renderSize,
        this.shape,
        this.color,
        this.weights[this.currentFrame],
        hasOpts
      );
    }
  }
}

// ============ SETUP ============

const VARIANTS = Object.keys(VARIANT_DEFS);
const SHAPES = ['circle', 'squircle'];
const COLORS = Object.keys(COLOR_SCHEMES);
const SIZINGS = Object.keys(SIZING_WEIGHTS);

// Build filter buttons
const filters = {
  variant: new Set(VARIANTS),
  shape: new Set(SHAPES),
  color: new Set(COLORS),
  sizing: new Set(SIZINGS),
};

function createFilterButtons(containerId, key, values) {
  const container = document.getElementById(containerId);
  values.forEach(v => {
    const btn = document.createElement('button');
    btn.className = 'toggle-btn active';
    btn.textContent = v;
    btn.addEventListener('click', () => {
      if (filters[key].has(v)) {
        filters[key].delete(v);
        btn.classList.remove('active');
      } else {
        filters[key].add(v);
        btn.classList.add('active');
      }
      applyFilters();
    });
    container.appendChild(btn);
  });
}

createFilterButtons('filter-variant', 'variant', VARIANTS);
createFilterButtons('filter-shape', 'shape', SHAPES);
createFilterButtons('filter-color', 'color', COLORS);
createFilterButtons('filter-sizing', 'sizing', SIZINGS);

function updateFilterSummary() {
  const parts = [];
  for (const [key, allVals] of [['variant', VARIANTS], ['shape', SHAPES], ['color', COLORS], ['sizing', SIZINGS]]) {
    const active = [...filters[key]];
    if (active.length === allVals.length) {
      parts.push(`${key}:*`);
    } else if (active.length > 0) {
      parts.push(`${key}:${active.join(',')}`);
    }
  }
  const summary = parts.join(' | ');
  const el = document.getElementById('filter-summary');
  el.textContent = summary;
}

document.getElementById('filter-summary').addEventListener('click', () => {
  const text = document.getElementById('filter-summary').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const el = document.getElementById('filter-summary');
    const orig = el.textContent;
    el.textContent = 'Copied!';
    setTimeout(() => { el.textContent = orig; }, 800);
  });
});

function applyFilters() {
  allCards.forEach(card => {
    if (card.customName) return; // custom cards always visible
    const show =
      filters.variant.has(card.variant) &&
      filters.shape.has(card.shape) &&
      filters.color.has(card.color) &&
      filters.sizing.has(card.sizing);
    card.visible = show;
    card.el.style.display = show ? '' : 'none';
  });
  updateFilterSummary();
}

// Speed slider
const speedSlider = document.getElementById('speed');
const speedVal = document.getElementById('speed-val');
speedSlider.addEventListener('input', () => {
  globalSpeed = parseFloat(speedSlider.value);
  speedVal.textContent = parseFloat(globalSpeed.toFixed(2)) + '×';
});

// Smooth rotation toggle
const smoothToggle = document.getElementById('smooth-toggle');
smoothToggle.addEventListener('click', () => {
  smoothRotation = !smoothRotation;
  smoothToggle.classList.toggle('active', smoothRotation);
});

// Favicon toggle
const faviconToggle = document.getElementById('favicon-toggle');
faviconToggle.addEventListener('click', () => {
  faviconMode = !faviconMode;
  faviconToggle.classList.toggle('active', faviconMode);
  document.getElementById('grid').classList.toggle('favicon-mode', faviconMode);
  allCards.forEach(card => card.resize());
});

// Build all cards
const grid = document.getElementById('grid');
for (const variant of VARIANTS) {
  for (const shape of SHAPES) {
    for (const color of COLORS) {
      for (const sizing of SIZINGS) {
        const card = new LogoCard({ variant, shape, color, sizing });
        allCards.push(card);
        grid.appendChild(card.el);
      }
    }
  }
}

// ============ CUSTOM AA VARIATIONS ============
// Anti-aliased J via dot sizing — heavy-7 + circle + dark/amber at small baseSize
// Each explores a different treatment of the center dot and AA fringe

// Weight matrix geometry for heavy-7 canonical [[0,0,1],[1,1,1],[1,1,1]]:
//   (0,0)=0  (0,1)=0  (0,2)=1  ← only top-right renders (stem tip)
//   (1,0)=1  (1,1)=1  (1,2)=1  ← hook arm, CENTER, stem body
//   (2,0)=1  (2,1)=1  (2,2)=1  ← full base row
//
// The J stroke (from hook-6 pattern) occupies: (0,2), (1,0), (1,2), (2,0), (2,1), (2,2)
// The ONLY non-J dot is (1,1) — center. It must be clearly smaller than the J stroke.
// (0,0) and (0,1) never render in any rotation of heavy-7, so their values don't matter.
//
// centerProfile: 8 values for frames 0-7. Center dot fluctuates —
// smallest at frame 4 (canonical J) and grows during rotation, creating a pulse.

const AA_VARIATIONS = [
  {
    stableId: 'AA1',
    // Clear J with gentle center pulse
    customName: 'aa-clear',
    variant: 'heavy-7', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    customBaseSize: 0.30,
    //                  n/a   n/a   stem
    customWeights: [[0.40, 0.30, 1.30],
    //              hook  ctr   stem
                    [0.80, 0.20, 1.10],
    //              base  base  base
                    [0.70, 0.85, 0.95]],
    //           build-up(0-4)          rotation(5-7)
    //           frames 0-2: center not present in matrix, value ignored
    //           frame 3: center first appears (partial J)
    //           frame 4: canonical = full J → center SMALLEST
    //           frames 5-7: rotation → center breathes up then back down
    centerProfile: [0.20, 0.20, 0.20, 0.20, 0.15, 0.35, 0.45, 0.30],
  },
  {
    stableId: 'AA2',
    // Bolder stroke, more dramatic center breathing
    customName: 'aa-bold',
    variant: 'heavy-7', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    customBaseSize: 0.30,
    customWeights: [[0.35, 0.25, 1.40],
                    [0.90, 0.20, 1.20],
                    [0.80, 0.95, 1.05]],
    centerProfile: [0.20, 0.20, 0.20, 0.20, 0.12, 0.40, 0.55, 0.35],
  },
  {
    stableId: 'AA3',
    // High contrast — stem pops hard, deep center dip
    customName: 'aa-contrast',
    variant: 'heavy-7', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    customBaseSize: 0.28,
    customWeights: [[0.30, 0.20, 1.50],
                    [0.95, 0.15, 1.25],
                    [0.85, 1.00, 1.10]],
    centerProfile: [0.15, 0.15, 0.15, 0.15, 0.10, 0.45, 0.60, 0.40],
  },
  {
    stableId: 'AA4',
    // Softer AA — narrower weight range, subtler center motion
    customName: 'aa-soft',
    variant: 'heavy-7', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    customBaseSize: 0.32,
    customWeights: [[0.45, 0.40, 1.20],
                    [0.75, 0.25, 1.05],
                    [0.70, 0.80, 0.90]],
    centerProfile: [0.25, 0.25, 0.25, 0.25, 0.20, 0.35, 0.42, 0.30],
  },
  {
    stableId: 'AA5',
    // Even base, strong graduated stem — reads like a well-hinted glyph
    customName: 'aa-hinted',
    variant: 'heavy-7', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    customBaseSize: 0.30,
    customWeights: [[0.40, 0.35, 1.35],
                    [0.85, 0.20, 1.15],
                    [0.75, 0.90, 0.95]],
    centerProfile: [0.20, 0.20, 0.20, 0.18, 0.13, 0.38, 0.50, 0.32],
  },
];

// ============ CENTER-PULSE FULL-9 VARIATIONS ============
// Full-9 with breathing center dot — smallest at canonical J, larger during rotation
// Smooth interpolation between frames handled by the existing rotation logic

const CENTER_PULSE_VARIATIONS = [
  {
    stableId: 'CP1',
    // full-9 wave, dark/light — center breathes: smallest at canonical (0°), largest at 180°
    customName: 'pulse-dl-wave',
    variant: 'full-9', shape: 'circle', color: 'dark/light', sizing: 'wave',
    customColors: { bg: '#1c1c1e', dot: '#f0efe8' },
    skipBuild: true,
    rotationPeriods: 8,
    // 8 rotation frames: 0°, 90°, 180°, 270°, 0°, 90°, 180°, 270°
    // Center smallest at 0° (canonical J), largest at 180°
    centerProfile: [0.20, 0.45, 0.65, 0.45, 0.20, 0.45, 0.65, 0.45],
  },
  {
    stableId: 'CP2',
    customName: 'pulse-dl-trail',
    variant: 'full-9', shape: 'circle', color: 'dark/light', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#f0efe8' },
    skipBuild: true,
    rotationPeriods: 8,
    centerProfile: [0.20, 0.45, 0.65, 0.45, 0.20, 0.45, 0.65, 0.45],
  },
  {
    stableId: 'CP3',
    customName: 'pulse-da-wave',
    variant: 'full-9', shape: 'circle', color: 'dark/amber', sizing: 'wave',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    skipBuild: true,
    rotationPeriods: 8,
    centerProfile: [0.20, 0.45, 0.65, 0.45, 0.20, 0.45, 0.65, 0.45],
  },
  {
    stableId: 'CP4',
    customName: 'pulse-da-trail',
    variant: 'full-9', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    skipBuild: true,
    rotationPeriods: 8,
    centerProfile: [0.20, 0.45, 0.65, 0.45, 0.20, 0.45, 0.65, 0.45],
  },
];

// ============ SMOOTH-TRAIL FULL-9 VARIATIONS ============
// Full-9 with 8 distinct weight matrices: each frame is a 45° angular step,
// interpolated between the 4 cardinal rotations of the trail weights.
// This halves the per-frame delta vs. repeating 4 rotations × 2.
//
// W_cardinal = [W0, R(W0), R²(W0), R³(W0)]
// W_smooth[2k]   = W_cardinal[k]
// W_smooth[2k+1] = lerp(W_cardinal[k], W_cardinal[(k+1)%4], 0.5)
//
// Center profile is cosine-shaped: smallest at 0° (J visible), largest at 180°.
// Values are hardcoded constants — deterministic across builds.

const SMOOTH_TRAIL_VARIATIONS = [
  {
    stableId: 'ST1',
    customName: 'smooth-da-trail',
    variant: 'full-9', shape: 'circle', color: 'dark/amber', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#e8a435' },
    skipBuild: true,
    rotationPeriods: 8,
    customRotWeights: [
      // P1 (0°) = W0
      [[0.40, 0.30, 1.30], [0.55, 0.20, 1.15], [0.70, 0.85, 1.00]],
      // P2 (45°) = lerp(W0, W1, 0.5)
      [[0.55, 0.43, 0.85], [0.70, 0.33, 0.73], [0.85, 1.00, 1.15]],
      // P3 (90°) = W1
      [[0.70, 0.55, 0.40], [0.85, 0.45, 0.30], [1.00, 1.15, 1.30]],
      // P4 (135°) = lerp(W1, W2, 0.5)
      [[0.85, 0.70, 0.55], [1.00, 0.55, 0.43], [1.15, 0.73, 0.85]],
      // P5 (180°) = W2
      [[1.00, 0.85, 0.70], [1.15, 0.65, 0.55], [1.30, 0.30, 0.40]],
      // P6 (225°) = lerp(W2, W3, 0.5)
      [[1.15, 1.00, 0.85], [0.73, 0.55, 0.70], [0.85, 0.43, 0.55]],
      // P7 (270°) = W3
      [[1.30, 1.15, 1.00], [0.30, 0.45, 0.85], [0.40, 0.55, 0.70]],
      // P8 (315°) = lerp(W3, W0, 0.5)
      [[0.85, 0.73, 1.15], [0.43, 0.33, 1.00], [0.55, 0.70, 0.85]],
    ],
  },
  {
    stableId: 'ST2',
    customName: 'smooth-dl-trail',
    variant: 'full-9', shape: 'circle', color: 'dark/light', sizing: 'trail',
    customColors: { bg: '#1c1c1e', dot: '#f0efe8' },
    skipBuild: true,
    rotationPeriods: 8,
    customRotWeights: [
      [[0.40, 0.30, 1.30], [0.55, 0.20, 1.15], [0.70, 0.85, 1.00]],
      [[0.55, 0.43, 0.85], [0.70, 0.33, 0.73], [0.85, 1.00, 1.15]],
      [[0.70, 0.55, 0.40], [0.85, 0.45, 0.30], [1.00, 1.15, 1.30]],
      [[0.85, 0.70, 0.55], [1.00, 0.55, 0.43], [1.15, 0.73, 0.85]],
      [[1.00, 0.85, 0.70], [1.15, 0.65, 0.55], [1.30, 0.30, 0.40]],
      [[1.15, 1.00, 0.85], [0.73, 0.55, 0.70], [0.85, 0.43, 0.55]],
      [[1.30, 1.15, 1.00], [0.30, 0.45, 0.85], [0.40, 0.55, 0.70]],
      [[0.85, 0.73, 1.15], [0.43, 0.33, 1.00], [0.55, 0.70, 0.85]],
    ],
  },
];

// Add smooth-trail divider + cards
const stDivider = document.createElement('div');
stDivider.className = 'grid-divider';
stDivider.textContent = 'Smooth Trail — full-9 with 8-step interpolated rotation';
grid.appendChild(stDivider);

for (const cfg of SMOOTH_TRAIL_VARIATIONS) {
  const card = new LogoCard(cfg);
  card.el.classList.add('custom-card');
  allCards.push(card);
  grid.appendChild(card.el);
}

// Add center-pulse divider + cards
const cpDivider = document.createElement('div');
cpDivider.className = 'grid-divider';
cpDivider.textContent = 'Center-Pulse — full-9 with breathing center dot';
grid.appendChild(cpDivider);

for (const cfg of CENTER_PULSE_VARIATIONS) {
  const card = new LogoCard(cfg);
  card.el.classList.add('custom-card');
  allCards.push(card);
  grid.appendChild(card.el);
}

// Add divider
const divider = document.createElement('div');
divider.className = 'grid-divider';
divider.textContent = 'AA Variations — anti-aliased J via dot sizing';
grid.appendChild(divider);

// Add custom cards
for (const cfg of AA_VARIATIONS) {
  const card = new LogoCard(cfg);
  card.el.classList.add('custom-card');
  allCards.push(card);
  grid.appendChild(card.el);
}

updateFilterSummary();

// Animation loop
let lastTime = performance.now();
function animate(now) {
  const dt = now - lastTime;
  lastTime = now;
  if (document.getElementById('detail').classList.contains('active')) {
    updateEditor(dt);
    drawEditorFrame();
  } else {
    for (const card of allCards) {
      card.update(dt);
      card.draw();
    }
  }
  requestAnimationFrame(animate);
}
// updateEditor/drawEditorFrame defined below; safe because RAF defers the first call
requestAnimationFrame(animate);

// ============ DETAIL / EDITOR VIEW ============

let editorCard = null;      // the LogoCard being edited
let editorPaused = false;
let editorSpeed = 1;
let editorFrame = 0;
let editorElapsed = 0;
// Editable state (independent of original card)
let edShape = 'circle';
let edBg = '#1c1c1e';
let edDot = '#f0efe8';
let edDotRatio = 0.6;
let edTimings = [];
let edFrames = [];
let edWeightFrames = [];
let edLoopStart = 5;
// 8-period rotation state
let edSkipBuild = false;
let edRotWeights = [];   // array of 8 3×3 matrices (one per rotation period)
let edEditPeriod = 0;    // which period (0-7) is being edited
let edRotTimingMs = 140; // single rotation timing for all periods
let edBuildTimings = [120, 120, 120, 140, 180];

const detailEl = document.getElementById('detail');
const gridEl = document.getElementById('grid');
const controlsEl = document.querySelector('.controls');
const headerEl = document.querySelector('h1');
const subtitleEl = document.querySelector('.subtitle');
const edCanvas = document.getElementById('editor-canvas');
const edCtx = edCanvas.getContext('2d');

function showEditor(card) {
  editorCard = card;

  edShape = card.shape;
  const colors = card.customColors || COLOR_SCHEMES[card.color];
  edBg = colors.bg;
  edDot = colors.dot;
  edDotRatio = card.customBaseSize || BASE_DOT_RATIO;
  edSkipBuild = card.skipBuild || false;

  // Extract 8 rotation weights from the card's actual weight frames
  const origRotPeriods = card.rotationPeriods || 4;
  if (card.skipBuild) {
    // All frames are rotation frames
    edRotWeights = card.weights.map(w => w.map(r => [...r]));
  } else {
    // Rotation starts at loopStart-1
    const rotStart = card.loopStart - 1;
    edRotWeights = [];
    for (let i = rotStart; i < card.weights.length; i++) {
      edRotWeights.push(card.weights[i].map(r => [...r]));
    }
  }
  // Extend to 8 periods if card had fewer
  while (edRotWeights.length < 8) {
    const srcIdx = edRotWeights.length % origRotPeriods;
    edRotWeights.push(edRotWeights[srcIdx].map(r => [...r]));
  }

  edEditPeriod = 0;
  edRotTimingMs = 140;
  edBuildTimings = [120, 120, 120, 140, 180];

  // Reset playback
  editorFrame = 0;
  editorElapsed = 0;
  editorPaused = false;
  editorSpeed = 1;

  // Rebuild frames from rotation state
  rebuildEditorFrames();

  // Populate UI
  document.getElementById('editor-title').textContent = `Editing #${card.id} — ${card.variant}`;
  populatePeriodSelector();
  populateWeightInputs();
  populateShapeButtons();
  populateColorPresets();
  syncColorInputs();
  populateTimingSliders();
  updateSkipBuildButton();
  document.getElementById('editor-dot-ratio').value = edDotRatio;
  document.getElementById('editor-dot-ratio-val').textContent = edDotRatio.toFixed(2);
  document.getElementById('editor-speed').value = editorSpeed;
  document.getElementById('editor-speed-val').textContent = editorSpeed + '×';
  updatePlaybackButtons();
  updateConfigOutput();

  // Setup canvas for HiDPI
  const s = 300;
  const dpr = window.devicePixelRatio || 1;
  edCanvas.width = s * dpr;
  edCanvas.height = s * dpr;
  edCanvas.style.width = s + 'px';
  edCanvas.style.height = s + 'px';
  edCtx.setTransform(1, 0, 0, 1, 0, 0);
  edCtx.scale(dpr, dpr);

  // Show editor, hide grid
  gridEl.style.display = 'none';
  controlsEl.style.display = 'none';
  headerEl.style.display = 'none';
  subtitleEl.style.display = 'none';
  detailEl.classList.add('active');
}

function hideEditor() {
  detailEl.classList.remove('active');
  gridEl.style.display = '';
  controlsEl.style.display = '';
  headerEl.style.display = '';
  subtitleEl.style.display = '';
  editorCard = null;
}

function rebuildEditorFrames() {
  if (!editorCard) return;
  const variant = editorCard.variant;
  const rotMatrices = buildRotationMatrices(variant, 8);

  if (edSkipBuild) {
    edFrames = rotMatrices;
    edWeightFrames = edRotWeights.map(w => w.map(r => [...r]));
    edTimings = Array(8).fill(edRotTimingMs);
    edLoopStart = 1;
  } else {
    const buildFrames = buildUpFrames(variant);
    edFrames = [...buildFrames, ...rotMatrices.slice(1)];
    edWeightFrames = [
      ...Array(5).fill(edRotWeights[0]),
      ...edRotWeights.slice(1),
    ];
    edTimings = [...edBuildTimings, ...Array(7).fill(edRotTimingMs)];
    edLoopStart = 5;
  }
}

// Custom drawFrame that uses editor state — with smooth rotation support
function drawEditorFrame() {
  const size = 300;

  edCtx.save();
  edCtx.setTransform(1, 0, 0, 1, 0, 0);
  const dpr = window.devicePixelRatio || 1;
  edCtx.scale(dpr, dpr);

  const inRotation = editorFrame >= edLoopStart - 1;
  if (smoothRotation && inRotation) {
    let next = editorFrame + 1;
    if (next >= edFrames.length) next = edLoopStart - 1;
    const t = Math.min(editorElapsed / edTimings[editorFrame], 1);
    drawFrameInterp(
      edCtx,
      edFrames[editorFrame], edFrames[next],
      size, edShape, null,
      edWeightFrames[editorFrame], edWeightFrames[next],
      t,
      { colors: { bg: edBg, dot: edDot }, baseDotRatio: edDotRatio }
    );
  } else {
    drawFrame(
      edCtx,
      edFrames[editorFrame],
      size, edShape, null,
      edWeightFrames[editorFrame],
      { colors: { bg: edBg, dot: edDot }, baseDotRatio: edDotRatio }
    );
  }

  edCtx.restore();
  updatePeriodHighlight();
}

// Editor animation (runs inside the main loop)
function updateEditor(dt) {
  if (!editorCard || editorPaused) return;
  editorElapsed += dt * editorSpeed;
  const frameDuration = edTimings[editorFrame];
  if (editorElapsed >= frameDuration) {
    editorElapsed -= frameDuration;
    editorFrame++;
    if (editorFrame >= edFrames.length) {
      editorFrame = edLoopStart - 1;
    }
  }
}

// ---- Period selector ----
function populatePeriodSelector() {
  const container = document.getElementById('editor-period-selector');
  container.innerHTML = '';
  for (let i = 0; i < 8; i++) {
    const btn = document.createElement('button');
    btn.className = 'period-btn' + (i === edEditPeriod ? ' active' : '');
    btn.textContent = (i + 1);
    btn.dataset.period = i;
    btn.addEventListener('click', () => {
      edEditPeriod = i;
      highlightActivePeriod();
      populateWeightInputs();
    });
    container.appendChild(btn);
  }
}

function highlightActivePeriod() {
  const btns = document.querySelectorAll('#editor-period-selector .period-btn');
  btns.forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.period) === edEditPeriod);
  });
}

// Update current-frame highlight on period buttons during animation
function updatePeriodHighlight() {
  const btns = document.querySelectorAll('#editor-period-selector .period-btn');
  // Map editor frame index to rotation period (0-7)
  let rotPeriod;
  if (edSkipBuild) {
    rotPeriod = editorFrame;
  } else {
    rotPeriod = editorFrame >= (edLoopStart - 1) ? editorFrame - (edLoopStart - 1) : -1;
  }
  btns.forEach(btn => {
    btn.classList.toggle('current-frame', parseInt(btn.dataset.period) === rotPeriod);
  });
}

// ---- Weight matrix inputs ----
function populateWeightInputs() {
  const container = document.getElementById('editor-weights');
  container.innerHTML = '';
  const w = edRotWeights[edEditPeriod];
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const inp = document.createElement('input');
      inp.type = 'number';
      inp.min = '0.1';
      inp.max = '2.0';
      inp.step = '0.05';
      inp.value = w[r][c].toFixed(2);
      inp.dataset.r = r;
      inp.dataset.c = c;
      const row = r, col = c;
      inp.addEventListener('input', () => {
        const v = parseFloat(inp.value);
        if (!isNaN(v) && v >= 0.1 && v <= 2.0) {
          edRotWeights[edEditPeriod][row][col] = v;
          rebuildEditorFrames();
          updateConfigOutput();
        }
      });
      container.appendChild(inp);
    }
  }
}

// ---- Skip build toggle ----
function updateSkipBuildButton() {
  const btn = document.getElementById('editor-skip-build');
  btn.textContent = edSkipBuild ? 'On' : 'Off';
  btn.classList.toggle('active', edSkipBuild);
}

document.getElementById('editor-skip-build').addEventListener('click', () => {
  edSkipBuild = !edSkipBuild;
  updateSkipBuildButton();
  rebuildEditorFrames();
  editorFrame = 0;
  editorElapsed = 0;
  populateTimingSliders();
  updateConfigOutput();
});

// ---- Shape toggle ----
function populateShapeButtons() {
  const btns = document.querySelectorAll('#editor-shape-row .toggle-btn');
  btns.forEach(btn => {
    btn.classList.toggle('active', btn.dataset.shape === edShape);
    btn.onclick = () => {
      edShape = btn.dataset.shape;
      btns.forEach(b => b.classList.toggle('active', b.dataset.shape === edShape));
      updateConfigOutput();
    };
  });
}

// ---- Color presets + custom ----
function populateColorPresets() {
  const container = document.getElementById('editor-color-presets');
  container.innerHTML = '';
  for (const [name, colors] of Object.entries(COLOR_SCHEMES)) {
    const btn = document.createElement('button');
    btn.className = 'color-preset-btn';
    btn.textContent = name;
    btn.addEventListener('click', () => {
      edBg = colors.bg;
      edDot = colors.dot;
      syncColorInputs();
      highlightActivePreset();
      updateConfigOutput();
    });
    container.appendChild(btn);
  }
  highlightActivePreset();
}

function highlightActivePreset() {
  const btns = document.querySelectorAll('#editor-color-presets .color-preset-btn');
  btns.forEach(btn => {
    const colors = COLOR_SCHEMES[btn.textContent];
    btn.classList.toggle('active', colors && colors.bg === edBg && colors.dot === edDot);
  });
}

function syncColorInputs() {
  document.getElementById('editor-bg-picker').value = edBg;
  document.getElementById('editor-bg-hex').value = edBg;
  document.getElementById('editor-dot-picker').value = edDot;
  document.getElementById('editor-dot-hex').value = edDot;
}

document.getElementById('editor-bg-picker').addEventListener('input', (e) => {
  edBg = e.target.value;
  document.getElementById('editor-bg-hex').value = edBg;
  highlightActivePreset();
  updateConfigOutput();
});
document.getElementById('editor-bg-hex').addEventListener('input', (e) => {
  if (/^#[0-9a-fA-F]{6}$/.test(e.target.value)) {
    edBg = e.target.value;
    document.getElementById('editor-bg-picker').value = edBg;
    highlightActivePreset();
    updateConfigOutput();
  }
});
document.getElementById('editor-dot-picker').addEventListener('input', (e) => {
  edDot = e.target.value;
  document.getElementById('editor-dot-hex').value = edDot;
  highlightActivePreset();
  updateConfigOutput();
});
document.getElementById('editor-dot-hex').addEventListener('input', (e) => {
  if (/^#[0-9a-fA-F]{6}$/.test(e.target.value)) {
    edDot = e.target.value;
    document.getElementById('editor-dot-picker').value = edDot;
    highlightActivePreset();
    updateConfigOutput();
  }
});

// ---- Dot ratio slider ----
document.getElementById('editor-dot-ratio').addEventListener('input', (e) => {
  edDotRatio = parseFloat(e.target.value);
  document.getElementById('editor-dot-ratio-val').textContent = edDotRatio.toFixed(2);
  updateConfigOutput();
});

// ---- Timing sliders ----
function populateTimingSliders() {
  const container = document.getElementById('editor-timings');
  container.innerHTML = '';

  // Build timings (hidden when skip-build is on)
  if (!edSkipBuild) {
    const buildLabels = ['Build 1', 'Build 2', 'Build 3', 'Build 4', 'Build 5'];
    edBuildTimings.forEach((ms, i) => {
      const row = document.createElement('div');
      row.className = 'editor-row';
      const lbl = document.createElement('label');
      lbl.textContent = buildLabels[i];
      const inp = document.createElement('input');
      inp.type = 'range';
      inp.min = '40';
      inp.max = '500';
      inp.step = '10';
      inp.value = ms;
      const val = document.createElement('span');
      val.className = 'val';
      val.textContent = ms + 'ms';
      const idx = i;
      inp.addEventListener('input', () => {
        edBuildTimings[idx] = parseInt(inp.value);
        val.textContent = inp.value + 'ms';
        rebuildEditorFrames();
        updateConfigOutput();
      });
      row.appendChild(lbl);
      row.appendChild(inp);
      row.appendChild(val);
      container.appendChild(row);
    });
  }

  // Rotation timing (single slider for all 8 periods)
  const rotRow = document.createElement('div');
  rotRow.className = 'editor-row';
  const rotLbl = document.createElement('label');
  rotLbl.textContent = 'Rotation';
  const rotInp = document.createElement('input');
  rotInp.type = 'range';
  rotInp.min = '40';
  rotInp.max = '500';
  rotInp.step = '10';
  rotInp.value = edRotTimingMs;
  const rotVal = document.createElement('span');
  rotVal.className = 'val';
  rotVal.textContent = edRotTimingMs + 'ms';
  rotInp.addEventListener('input', () => {
    edRotTimingMs = parseInt(rotInp.value);
    rotVal.textContent = rotInp.value + 'ms';
    rebuildEditorFrames();
    updateConfigOutput();
  });
  rotRow.appendChild(rotLbl);
  rotRow.appendChild(rotInp);
  rotRow.appendChild(rotVal);
  container.appendChild(rotRow);
}

// ---- Playback controls ----
function updatePlaybackButtons() {
  document.getElementById('ep-play').classList.toggle('active', !editorPaused);
  document.getElementById('ep-pause').classList.toggle('active', editorPaused);
}

document.getElementById('ep-play').addEventListener('click', () => {
  editorPaused = false;
  updatePlaybackButtons();
});
document.getElementById('ep-pause').addEventListener('click', () => {
  editorPaused = true;
  updatePlaybackButtons();
});
document.getElementById('ep-step').addEventListener('click', () => {
  editorPaused = true;
  editorFrame++;
  if (editorFrame >= edFrames.length) {
    editorFrame = edLoopStart - 1;
  }
  editorElapsed = 0;
  updatePlaybackButtons();
  drawEditorFrame();
});

document.getElementById('editor-speed').addEventListener('input', (e) => {
  editorSpeed = parseFloat(e.target.value);
  document.getElementById('editor-speed-val').textContent = editorSpeed + '×';
});

// ---- Back button ----
document.getElementById('editor-back').addEventListener('click', hideEditor);

// ---- Copy config ----
function buildConfigString() {
  const card = editorCard;
  const fmtW = (w) => `[[${w[0].map(v=>v.toFixed(2)).join(',')}],[${w[1].map(v=>v.toFixed(2)).join(',')}],[${w[2].map(v=>v.toFixed(2)).join(',')}]]`;

  let lines = [`JENNER_EDIT:`];
  lines.push(`  variant=${card.variant} shape=${edShape} bg=${edBg} dot=${edDot} baseSize=${edDotRatio.toFixed(2)}`);
  lines.push(`  skipBuild=${edSkipBuild} rotMs=${edRotTimingMs}`);
  if (!edSkipBuild) {
    lines.push(`  buildMs=${edBuildTimings.join(',')}`);
  }
  for (let i = 0; i < 8; i++) {
    lines.push(`  P${i+1}=${fmtW(edRotWeights[i])}`);
  }
  return lines.join('\n');
}

function updateConfigOutput() {
  if (!editorCard) return;
  document.getElementById('editor-config-output').value = buildConfigString();
}

document.getElementById('editor-copy').addEventListener('click', () => {
  const text = buildConfigString();
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('editor-copy');
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = orig; }, 1000);
  });
});

// ============ EXPORT ASSET PACK ============

// Platform size definitions
const EXPORT_SIZES = {
  favicon:   [16, 32, 48, 64, 96, 128, 256],
  web:       [180, 192, 512, 1200],
  macos:     [16, 32, 64, 128, 256, 512, 1024],
  windows:   [16, 24, 32, 48, 64, 128, 256],
  linux:     [16, 22, 24, 32, 48, 64, 96, 128, 256, 512],
  marketing: [1024, 2048, 4096],
};

// Filename prefixes per platform
const EXPORT_NAMES = {
  favicon:   (s) => `favicon-${s}.png`,
  web:       (s) => {
    if (s === 180) return 'apple-touch-icon-180.png';
    if (s === 192) return 'pwa-192.png';
    if (s === 512) return 'pwa-512.png';
    if (s === 1200) return 'og-1200.png';
    return `web-${s}.png`;
  },
  macos:     (s) => `icon-${s}.png`,
  windows:   (s) => `icon-${s}.png`,
  linux:     (s) => `icon-${s}.png`,
  marketing: (s) => `logo-${s}.png`,
};

// Background variations
function getExportVariations(edBgColor, edDotColor) {
  // Determine if dot is light or dark for fallbacks
  function luminance(hex) {
    const r = parseInt(hex.slice(1,3), 16) / 255;
    const g = parseInt(hex.slice(3,5), 16) / 255;
    const b = parseInt(hex.slice(5,7), 16) / 255;
    return 0.299 * r + 0.587 * g + 0.114 * b;
  }
  const dotLum = luminance(edDotColor);
  // For on-white: use dot color if dark enough, else use near-black
  const onWhiteDot = dotLum < 0.6 ? edDotColor : '#1c1c1e';
  // For on-black: use dot color if light enough, else use near-white
  const onBlackDot = dotLum > 0.4 ? edDotColor : '#f0efe8';

  return {
    'original':       { bg: edBgColor, dot: edDotColor, transparent: false },
    'transparent':    { bg: null,      dot: edDotColor, transparent: true },
    'on-white':       { bg: '#ffffff', dot: onWhiteDot, transparent: false },
    'on-black':       { bg: '#000000', dot: onBlackDot, transparent: false },
    'color-on-white': { bg: '#ffffff', dot: edDotColor, transparent: false },
    'color-on-black': { bg: '#000000', dot: edDotColor, transparent: false },
    'mono-on-white':  { bg: '#ffffff', dot: '#1c1c1e',  transparent: false },
    'mono-on-black':  { bg: '#000000', dot: '#f0efe8',  transparent: false },
  };
}

// Render a single export canvas at a given size
function renderExportCanvas(size, bgColor, dotColor, shape, matrix, weights, dotRatio, transparent) {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');

  const cellSize = size / 3;
  const baseDotR = (cellSize * dotRatio) / 2;

  // Background
  if (!transparent) {
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, size, size);
  }

  // Dots
  ctx.fillStyle = dotColor;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (!matrix[r][c]) continue;
      const scale = weights[r][c];
      const dr = baseDotR * scale;
      const cx = cellSize * c + cellSize / 2;
      const cy = cellSize * r + cellSize / 2;
      if (shape === 'circle') {
        ctx.beginPath();
        ctx.arc(cx, cy, dr, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const sr = dr * 0.35;
        const s = dr * 2;
        ctx.beginPath();
        ctx.roundRect(cx - dr, cy - dr, s, s, sr);
        ctx.fill();
      }
    }
  }
  return canvas;
}

// Generate SVG string from parameters
function generateExportSVG(svgSize, bgColor, dotColor, shape, matrix, weights, dotRatio, transparent) {
  const size = svgSize || 512;
  const cellSize = size / 3;
  const baseDotR = (cellSize * dotRatio) / 2;

  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">\n`;

  // Background
  if (!transparent) {
    svg += `  <rect width="${size}" height="${size}" fill="${bgColor}"/>\n`;
  }

  // Dots
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (!matrix[r][c]) continue;
      const scale = weights[r][c];
      const dr = baseDotR * scale;
      const cx = cellSize * c + cellSize / 2;
      const cy = cellSize * r + cellSize / 2;
      if (shape === 'circle') {
        svg += `  <circle cx="${cx.toFixed(2)}" cy="${cy.toFixed(2)}" r="${dr.toFixed(2)}" fill="${dotColor}"/>\n`;
      } else {
        const sr = dr * 0.35;
        const s = dr * 2;
        svg += `  <rect x="${(cx - dr).toFixed(2)}" y="${(cy - dr).toFixed(2)}" width="${s.toFixed(2)}" height="${s.toFixed(2)}" rx="${sr.toFixed(2)}" ry="${sr.toFixed(2)}" fill="${dotColor}"/>\n`;
      }
    }
  }

  svg += `</svg>`;
  return svg;
}

// ============ ANIMATION EXPORT FUNCTIONS ============

// Render an interpolated export canvas (between two frames)
function renderExportCanvasInterp(size, bgColor, dotColor, shape, matA, matB, weightsA, weightsB, t, dotRatio, transparent) {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');

  const cellSize = size / 3;
  const baseDotR = (cellSize * dotRatio) / 2;

  // Smoothstep easing
  const st = t * t * (3 - 2 * t);

  // Background
  if (!transparent) {
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, size, size);
  }

  // Dots
  ctx.fillStyle = dotColor;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const inA = matA[r][c];
      const inB = matB[r][c];
      if (!inA && !inB) continue;

      let scale;
      if (inA && inB) {
        scale = weightsA[r][c] * (1 - st) + weightsB[r][c] * st;
      } else if (inA) {
        scale = weightsA[r][c] * (1 - st);
      } else {
        scale = weightsB[r][c] * st;
      }
      if (scale < 0.01) continue;

      const dr = baseDotR * scale;
      const cx = cellSize * c + cellSize / 2;
      const cy = cellSize * r + cellSize / 2;
      if (shape === 'circle') {
        ctx.beginPath();
        ctx.arc(cx, cy, dr, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const sr = dr * 0.35;
        const s = dr * 2;
        ctx.beginPath();
        ctx.roundRect(cx - dr, cy - dr, s, s, sr);
        ctx.fill();
      }
    }
  }
  return canvas;
}

// Capture animation frames for the rotation loop with sub-frame interpolation
function captureAnimationFrames(size, bgColor, dotColor, shape, dotRatio, transparent, frames, weightFrames, timings, loopStart, speed) {
  const SUBSTEPS = 6; // sub-frames per transition
  const speedFactor = 1 / (speed || 1); // slower speed = longer delays
  const result = [];
  const rotStart = loopStart - 1; // index of first rotation frame
  const rotEnd = frames.length;
  const rotCount = rotEnd - rotStart;

  for (let i = 0; i < rotCount; i++) {
    const frameIdx = rotStart + i;
    const nextIdx = rotStart + ((i + 1) % rotCount);
    const delayMs = Math.round((timings[frameIdx] * speedFactor) / SUBSTEPS);

    for (let sub = 0; sub < SUBSTEPS; sub++) {
      const t = sub / SUBSTEPS;
      if (sub === 0) {
        // Exact keyframe — no interpolation needed
        const canvas = renderExportCanvas(
          size, bgColor, dotColor, shape,
          frames[frameIdx], weightFrames[frameIdx],
          dotRatio, transparent
        );
        result.push({ canvas, delayMs });
      } else {
        const canvas = renderExportCanvasInterp(
          size, bgColor, dotColor, shape,
          frames[frameIdx], frames[nextIdx],
          weightFrames[frameIdx], weightFrames[nextIdx],
          t, dotRatio, transparent
        );
        result.push({ canvas, delayMs });
      }
    }
  }
  return result;
}

// Generate animated GIF from captured frames using gif.js
function generateGIF(animFrames, size) {
  return new Promise((resolve, reject) => {
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: size,
      height: size,
      workerScript: window._gifWorkerBlobURL,
      transparent: null,
    });

    for (const frame of animFrames) {
      gif.addFrame(frame.canvas, { delay: frame.delayMs, copy: true });
    }

    gif.on('finished', (blob) => resolve(blob));
    gif.on('error', (err) => reject(err));
    gif.render();
  });
}

// Generate sprite sheet (horizontal strip) + CSS keyframes
function generateSpriteSheet(animFrames, size) {
  const count = animFrames.length;
  const canvas = document.createElement('canvas');
  canvas.width = size * count;
  canvas.height = size;
  const ctx = canvas.getContext('2d');

  for (let i = 0; i < count; i++) {
    ctx.drawImage(animFrames[i].canvas, i * size, 0);
  }

  // Calculate total duration
  let totalMs = 0;
  for (const f of animFrames) totalMs += f.delayMs;

  // Build CSS keyframes with per-frame percentages
  let css = `/* Jenner Logo Sprite Animation */\n`;
  css += `.jenner-logo {\n`;
  css += `  width: ${size}px;\n`;
  css += `  height: ${size}px;\n`;
  css += `  background-size: ${size * count}px ${size}px;\n`;
  css += `  animation: jenner-rotate ${(totalMs / 1000).toFixed(2)}s steps(1) infinite;\n`;
  css += `}\n\n`;
  css += `@keyframes jenner-rotate {\n`;

  let elapsed = 0;
  for (let i = 0; i < count; i++) {
    const pct = ((elapsed / totalMs) * 100).toFixed(2);
    css += `  ${pct}% { background-position: -${i * size}px 0; }\n`;
    elapsed += animFrames[i].delayMs;
  }
  css += `  100% { background-position: 0 0; }\n`;
  css += `}\n`;

  return new Promise((resolve) => {
    canvas.toBlob((blob) => {
      resolve({ png: blob, css });
    }, 'image/png');
  });
}

// Generate APNG from captured frames
function generateAPNG(animFrames, size) {
  // Encode each frame as PNG ArrayBuffer, then assemble APNG
  const framePNGs = [];

  function canvasToPNGArrayBuffer(canvas) {
    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        blob.arrayBuffer().then(resolve);
      }, 'image/png');
    });
  }

  return Promise.all(animFrames.map(f => canvasToPNGArrayBuffer(f.canvas))).then(pngBuffers => {
    // Parse each PNG to extract IDAT chunks and the IHDR from the first
    function parsePNG(buf) {
      const view = new DataView(buf);
      const chunks = [];
      let offset = 8; // skip PNG signature
      while (offset < buf.byteLength) {
        const length = view.getUint32(offset);
        const typeBytes = new Uint8Array(buf, offset + 4, 4);
        const type = String.fromCharCode(...typeBytes);
        const data = new Uint8Array(buf, offset + 8, length);
        chunks.push({ type, data, length });
        offset += 12 + length; // 4 len + 4 type + data + 4 crc
      }
      return chunks;
    }

    const allParsed = pngBuffers.map(parsePNG);
    const firstIHDR = allParsed[0].find(c => c.type === 'IHDR');
    const numFrames = animFrames.length;

    // Helper: compute CRC32
    let crcTable = null;
    function makeCRCTable() {
      const t = new Uint32Array(256);
      for (let n = 0; n < 256; n++) {
        let c = n;
        for (let k = 0; k < 8; k++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        t[n] = c;
      }
      return t;
    }
    function crc32(buf) {
      if (!crcTable) crcTable = makeCRCTable();
      let crc = 0xFFFFFFFF;
      for (let i = 0; i < buf.length; i++) crc = crcTable[(crc ^ buf[i]) & 0xFF] ^ (crc >>> 8);
      return (crc ^ 0xFFFFFFFF) >>> 0;
    }

    // Helper: create a chunk (returns Uint8Array for length+type+data+crc)
    function makeChunk(type, data) {
      const typeArr = new Uint8Array([...type].map(c => c.charCodeAt(0)));
      const buf = new Uint8Array(12 + data.length);
      const view = new DataView(buf.buffer);
      view.setUint32(0, data.length);
      buf.set(typeArr, 4);
      buf.set(data, 8);
      // CRC over type+data
      const crcBuf = new Uint8Array(4 + data.length);
      crcBuf.set(typeArr, 0);
      crcBuf.set(data, 4);
      view.setUint32(8 + data.length, crc32(crcBuf));
      return buf;
    }

    // Build APNG
    const parts = [];

    // PNG signature
    parts.push(new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]));

    // IHDR chunk (from first frame)
    parts.push(makeChunk('IHDR', firstIHDR.data));

    // acTL (animation control) — 8 bytes: num_frames (4), num_plays=0 (4, infinite)
    const acTLData = new Uint8Array(8);
    const acTLView = new DataView(acTLData.buffer);
    acTLView.setUint32(0, numFrames);
    acTLView.setUint32(4, 0); // loop forever
    parts.push(makeChunk('acTL', acTLData));

    let seqNum = 0;

    for (let i = 0; i < numFrames; i++) {
      const delayMs = animFrames[i].delayMs;
      // Simplify delay fraction: delayMs/1000 -> num/den
      const delayNum = delayMs;
      const delayDen = 1000;

      // fcTL (frame control) — 26 bytes
      const fcTLData = new Uint8Array(26);
      const fcTLView = new DataView(fcTLData.buffer);
      fcTLView.setUint32(0, seqNum++);     // sequence_number
      fcTLView.setUint32(4, size);          // width
      fcTLView.setUint32(8, size);          // height
      fcTLView.setUint32(12, 0);           // x_offset
      fcTLView.setUint32(16, 0);           // y_offset
      fcTLView.setUint16(20, delayNum);    // delay_num
      fcTLView.setUint16(22, delayDen);    // delay_den
      fcTLData[24] = 0;                     // dispose_op: APNG_DISPOSE_OP_NONE
      fcTLData[25] = 0;                     // blend_op: APNG_BLEND_OP_SOURCE
      parts.push(makeChunk('fcTL', fcTLData));

      // Get IDAT data from this frame's PNG
      const idatChunks = allParsed[i].filter(c => c.type === 'IDAT');

      if (i === 0) {
        // First frame uses IDAT (for backwards compatibility with non-APNG viewers)
        for (const chunk of idatChunks) {
          parts.push(makeChunk('IDAT', chunk.data));
        }
      } else {
        // Subsequent frames use fdAT (= sequence_number + IDAT data)
        for (const chunk of idatChunks) {
          const fdATData = new Uint8Array(4 + chunk.data.length);
          const fdATView = new DataView(fdATData.buffer);
          fdATView.setUint32(0, seqNum++);
          fdATData.set(chunk.data, 4);
          parts.push(makeChunk('fdAT', fdATData));
        }
      }
    }

    // IEND
    parts.push(makeChunk('IEND', new Uint8Array(0)));

    // Concatenate all parts
    let totalLen = 0;
    for (const p of parts) totalLen += p.length;
    const result = new Uint8Array(totalLen);
    let off = 0;
    for (const p of parts) {
      result.set(p, off);
      off += p.length;
    }

    return new Blob([result], { type: 'image/png' });
  });
}

// Convert canvas to blob (Promise-based)
function canvasToBlob(canvas) {
  return new Promise((resolve) => {
    canvas.toBlob((blob) => resolve(blob), 'image/png');
  });
}

// Export orchestrator
document.getElementById('export-btn').addEventListener('click', async () => {
  if (!editorCard) return;

  const btn = document.getElementById('export-btn');
  const progressDiv = document.getElementById('export-progress');
  const progressBar = document.getElementById('export-bar');
  const statusEl = document.getElementById('export-status');

  btn.disabled = true;
  progressDiv.style.display = 'block';
  progressBar.value = 0;
  statusEl.textContent = 'Preparing...';

  try {
    // Determine which frame to export
    const frameSel = document.getElementById('export-frame').value;
    let frameIdx;
    if (frameSel === 'current') {
      frameIdx = editorFrame;
    } else {
      // canonical = first rotation frame (period 0)
      frameIdx = edSkipBuild ? 0 : (edLoopStart - 1);
    }
    const matrix = edFrames[frameIdx];
    const weights = edWeightFrames[frameIdx];

    // Get variations
    const variations = getExportVariations(edBg, edDot);
    const variationKeys = Object.keys(variations);
    const platformKeys = Object.keys(EXPORT_SIZES);

    // Count total renders for progress
    let totalRenders = 0;
    for (const pk of platformKeys) {
      totalRenders += EXPORT_SIZES[pk].length;
    }
    totalRenders *= variationKeys.length; // PNG renders
    totalRenders += variationKeys.length;  // SVG renders
    // Animation renders: 4 outputs per variation (GIF 256, GIF 512, sprite, APNG)
    totalRenders += variationKeys.length * 4;
    let completedRenders = 0;

    const zip = new JSZip();
    const root = zip.folder('jenner-logo-export');

    // Generate PNGs for each variation × platform × size
    for (const vk of variationKeys) {
      const v = variations[vk];
      const varFolder = root.folder(vk);

      for (const pk of platformKeys) {
        const platFolder = varFolder.folder(pk);
        const sizes = EXPORT_SIZES[pk];

        for (const size of sizes) {
          const canvas = renderExportCanvas(
            size, v.bg, v.dot, edShape, matrix, weights, edDotRatio, v.transparent
          );
          const blob = await canvasToBlob(canvas);
          const filename = EXPORT_NAMES[pk](size);
          platFolder.file(filename, blob);

          completedRenders++;
          const pct = Math.round((completedRenders / totalRenders) * 100);
          progressBar.value = pct;
          statusEl.textContent = `Rendering ${vk}/${pk}/${size}px... (${pct}%)`;

          // Yield to UI thread every few renders
          if (completedRenders % 5 === 0) {
            await new Promise(r => setTimeout(r, 0));
          }
        }
      }
    }

    // Generate SVGs
    const svgFolder = root.folder('svg');
    for (const vk of variationKeys) {
      const v = variations[vk];
      const svgStr = generateExportSVG(512, v.bg, v.dot, edShape, matrix, weights, edDotRatio, v.transparent);
      svgFolder.file(`logo-${vk}.svg`, svgStr);
      completedRenders++;
      const pct = Math.round((completedRenders / totalRenders) * 100);
      progressBar.value = pct;
      statusEl.textContent = `Generating SVG (${vk})... (${pct}%)`;
    }

    // Generate Animations
    const animFolder = root.folder('animation');
    for (const vk of variationKeys) {
      const v = variations[vk];
      statusEl.textContent = `Generating animations (${vk})...`;
      await new Promise(r => setTimeout(r, 0)); // yield to UI

      // Capture frames at 256px
      const frames256 = captureAnimationFrames(
        256, v.bg || '#000000', v.dot, edShape,
        edDotRatio, v.transparent, edFrames, edWeightFrames, edTimings, edLoopStart, editorSpeed
      );

      // GIF at 256px
      const gif256Blob = await generateGIF(frames256, 256);
      animFolder.file(`logo-${vk}.gif`, gif256Blob);
      completedRenders++;
      progressBar.value = Math.round((completedRenders / totalRenders) * 100);
      statusEl.textContent = `Animation: GIF 256 (${vk})`;
      await new Promise(r => setTimeout(r, 0));

      // GIF at 512px
      const frames512 = captureAnimationFrames(
        512, v.bg || '#000000', v.dot, edShape,
        edDotRatio, v.transparent, edFrames, edWeightFrames, edTimings, edLoopStart, editorSpeed
      );
      const gif512Blob = await generateGIF(frames512, 512);
      animFolder.file(`logo-${vk}-512.gif`, gif512Blob);
      completedRenders++;
      progressBar.value = Math.round((completedRenders / totalRenders) * 100);
      statusEl.textContent = `Animation: GIF 512 (${vk})`;
      await new Promise(r => setTimeout(r, 0));

      // Sprite sheet at 256px (reuse frames256)
      const sprite = await generateSpriteSheet(frames256, 256);
      animFolder.file(`sprite-${vk}.png`, sprite.png);
      animFolder.file(`sprite-${vk}.css`, sprite.css);
      completedRenders++;
      progressBar.value = Math.round((completedRenders / totalRenders) * 100);
      statusEl.textContent = `Animation: sprite (${vk})`;
      await new Promise(r => setTimeout(r, 0));

      // APNG at 256px (reuse frames256)
      const apngBlob = await generateAPNG(frames256, 256);
      animFolder.file(`logo-${vk}.apng`, apngBlob);
      completedRenders++;
      progressBar.value = Math.round((completedRenders / totalRenders) * 100);
      statusEl.textContent = `Animation: APNG (${vk})`;
      await new Promise(r => setTimeout(r, 0));
    }

    // Generate ZIP
    statusEl.textContent = 'Compressing ZIP...';
    const blob = await zip.generateAsync({ type: 'blob' }, (metadata) => {
      progressBar.value = Math.round(metadata.percent);
    });

    // Trigger download
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'jenner-logo-export.zip';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    statusEl.textContent = 'Done! ZIP downloaded.';
    progressBar.value = 100;
  } catch (err) {
    statusEl.textContent = 'Error: ' + err.message;
    console.error('Export error:', err);
  } finally {
    btn.disabled = false;
    setTimeout(() => {
      progressDiv.style.display = 'none';
    }, 3000);
  }
});

</script>
</body>
</html>
